---
name: postgresql-table-design
description: 設計 PostgreSQL 專屬架構。涵蓋最佳實務、資料型別、索引、條件約束、效能模式及進階功能
---

# PostgreSQL 資料表設計

## 核心規則

- 為參照資料表(users、orders 等)定義 **PRIMARY KEY**。時間序列/事件/日誌資料並非總是需要。使用時,優先選擇 `BIGINT GENERATED ALWAYS AS IDENTITY`;僅在需要全域唯一性/不透明性時才使用 `UUID`。
- **先正規化(至 3NF)** 以消除資料冗餘和更新異常;**僅**在已測量、高投資報酬率的讀取操作中,且連線效能確實有問題時才進行反正規化。過早反正規化會造成維護負擔。
- 在語意上必要的地方都加上 **NOT NULL**;為常見值使用 **DEFAULT**。
- 為實際查詢的存取路徑建立 **索引**: PK/unique(自動)、**FK 欄位(手動!)**、頻繁的篩選/排序,以及連線鍵值。
- 事件時間優先使用 **TIMESTAMPTZ**;金額使用 **NUMERIC**;字串使用 **TEXT**;整數值使用 **BIGINT**,浮點數使用 **DOUBLE PRECISION**(或精確十進位運算使用 `NUMERIC`)。

## PostgreSQL "陷阱"

- **識別符號**: 未加引號 → 轉為小寫。避免使用引號/混合大小寫名稱。慣例:資料表/欄位名稱使用 `snake_case`。
- **Unique + NULLs**: UNIQUE 允許多個 NULL。使用 `UNIQUE (...) NULLS NOT DISTINCT`(PG15+)來限制為一個 NULL。
- **FK 索引**: PostgreSQL **不會**自動為 FK 欄位建立索引。請手動新增。
- **無靜默強制轉換**: 長度/精度溢位會產生錯誤(不會截斷)。例如:將 999 插入 `NUMERIC(2,0)` 會失敗並產生錯誤,不像某些資料庫會靜默截斷或四捨五入。
- **序列/identity 有間隙**(正常現象;不要"修復")。復原、當機和並行交易會在 ID 序列中造成間隙(1、2、5、6...)。這是預期行為—不要試圖讓 ID 連續。
- **堆積儲存**: 預設無叢集 PK(不像 SQL Server/MySQL InnoDB);`CLUSTER` 是一次性重組,不會在後續插入時維護。磁碟上的列順序是插入順序,除非明確叢集化。
- **MVCC**: 更新/刪除會留下死元組;vacuum 處理它們—設計時避免頻繁的寬列更新。

## 資料型別

- **ID**: 優先使用 `BIGINT GENERATED ALWAYS AS IDENTITY`(`GENERATED BY DEFAULT` 也可以);在合併/聯合/分散式系統中使用,或需要不透明 ID 時使用 `UUID`。使用 `uuidv7()`(PG18+ 優先使用)或 `gen_random_uuid()`(較舊 PG 版本)產生。
- **整數**: 優先使用 `BIGINT`,除非儲存空間至關重要;較小範圍使用 `INTEGER`;除非受限,否則避免使用 `SMALLINT`。
- **浮點數**: 優先使用 `DOUBLE PRECISION` 而非 `REAL`,除非儲存空間至關重要。精確十進位運算使用 `NUMERIC`。
- **字串**: 優先使用 `TEXT`;如需長度限制,使用 `CHECK (LENGTH(col) <= n)` 而非 `VARCHAR(n)`;避免使用 `CHAR(n)`。二進位資料使用 `BYTEA`。大字串/二進位(預設閾值 >2KB)會自動以壓縮方式儲存在 TOAST 中。TOAST 儲存:`PLAIN`(無 TOAST)、`EXTENDED`(壓縮 + 行外)、`EXTERNAL`(行外,無壓縮)、`MAIN`(壓縮,盡可能保持行內)。預設 `EXTENDED` 通常最佳。使用 `ALTER TABLE tbl ALTER COLUMN col SET STORAGE strategy` 和 `ALTER TABLE tbl SET (toast_tuple_target = 4096)` 設定閾值來控制。不區分大小寫:區域/重音處理使用非確定性校對;純 ASCII 使用 `LOWER(col)` 的表示式索引(優先使用,除非欄位需要不區分大小寫的 PK/FK/UNIQUE)或 `CITEXT`。
- **金額**: `NUMERIC(p,s)`(絕不使用浮點數)。
- **時間**: 時間戳記使用 `TIMESTAMPTZ`;僅日期使用 `DATE`;期間使用 `INTERVAL`。避免使用 `TIMESTAMP`(不含時區)。交易開始時間使用 `now()`,當前掛鐘時間使用 `clock_timestamp()`。
- **布林值**: `BOOLEAN` 配合 `NOT NULL` 條件約束,除非需要三態值。
- **列舉**: 小型、穩定的集合(例如美國州名、星期幾)使用 `CREATE TYPE ... AS ENUM`。業務邏輯驅動且不斷演進的值(例如訂單狀態)→ 使用 TEXT(或 INT)+ CHECK 或查閱資料表。
- **陣列**: `TEXT[]`、`INTEGER[]` 等。用於查詢元素的有序清單。使用 **GIN** 索引進行包含(`@>`、`<@`)和重疊(`&&`)查詢。存取:`arr[1]`(1 索引)、`arr[1:3]`(切片)。適合標籤、分類;關聯避免使用—改用連接資料表。文字語法:`'{val1,val2}'` 或 `ARRAY[val1,val2]`。
- **範圍型別**: 間隔使用 `daterange`、`numrange`、`tstzrange`。支援重疊(`&&`)、包含(`@>`)、運算子。使用 **GiST** 索引。適合排程、版本控制、數值範圍。選擇邊界方案並一致使用;預設優先使用 `[)`(含/不含)。
- **網路型別**: IP 位址使用 `INET`,網路範圍使用 `CIDR`,MAC 位址使用 `MACADDR`。支援網路運算子(`<<`、`>>`、`&&`)。
- **幾何型別**: 2D 空間資料使用 `POINT`、`LINE`、`POLYGON`、`CIRCLE`。使用 **GiST** 索引。進階空間功能考慮 **PostGIS**。
- **文字搜尋**: 全文搜尋文件使用 `TSVECTOR`,搜尋查詢使用 `TSQUERY`。使用 **GIN** 索引 `tsvector`。務必指定語言:`to_tsvector('english', col)` 和 `to_tsquery('english', 'query')`。絕不使用單一參數版本。這適用於索引表示式和查詢。
- **網域型別**: 可重複使用的自訂型別配合驗證使用 `CREATE DOMAIN email AS TEXT CHECK (VALUE ~ '^[^@]+@[^@]+$')`。跨資料表強制執行條件約束。
- **複合型別**: 欄位內的結構化資料使用 `CREATE TYPE address AS (street TEXT, city TEXT, zip TEXT)`。使用 `(col).field` 語法存取。
- **JSONB**: 優先於 JSON;使用 **GIN** 索引。僅用於選用/半結構化屬性。僅在必須保留內容的原始順序時才使用 JSON。
- **向量型別**: `pgvector` 的 `vector` 型別用於嵌入的向量相似度搜尋。


### 不要使用以下資料型別
- 不要使用 `timestamp`(不含時區);要使用 `timestamptz`。
- 不要使用 `char(n)` 或 `varchar(n)`;要使用 `text`。
- 不要使用 `money` 型別;要使用 `numeric`。
- 不要使用 `timetz` 型別;要使用 `timestamptz`。
- 不要使用 `timestamptz(0)` 或任何其他精度規格;要使用 `timestamptz`。
- 不要使用 `serial` 型別;要使用 `generated always as identity`。


## 資料表型別

- **Regular**: 預設;完全持久、已記錄。
- **TEMPORARY**: 工作階段範圍,自動刪除,未記錄。暫存工作更快。
- **UNLOGGED**: 持久但不防當機。寫入更快;適合快取/暫存。

## 列級安全性

使用 `ALTER TABLE tbl ENABLE ROW LEVEL SECURITY` 啟用。建立原則:`CREATE POLICY user_access ON orders FOR SELECT TO app_users USING (user_id = current_user_id())`。列級內建的基於使用者的存取控制。

## 條件約束

- **PK**: 隱含 UNIQUE + NOT NULL;建立 B-tree 索引。
- **FK**: 指定 `ON DELETE/UPDATE` 動作(`CASCADE`、`RESTRICT`、`SET NULL`、`SET DEFAULT`)。在參照欄位上新增明確索引—加速連線並防止父刪除/更新時的鎖定問題。循環 FK 相依性在交易結束時檢查,使用 `DEFERRABLE INITIALLY DEFERRED`。
- **UNIQUE**: 建立 B-tree 索引;允許多個 NULL,除非使用 `NULLS NOT DISTINCT`(PG15+)。標準行為:允許 `(1, NULL)` 和 `(1, NULL)`。使用 `NULLS NOT DISTINCT`:僅允許一個 `(1, NULL)`。優先使用 `NULLS NOT DISTINCT`,除非特別需要重複的 NULL。
- **CHECK**: 列本地條件約束;NULL 值通過檢查(三值邏輯)。例如:`CHECK (price > 0)` 允許 NULL 價格。結合 `NOT NULL` 強制執行:`price NUMERIC NOT NULL CHECK (price > 0)`。
- **EXCLUDE**: 使用運算子防止重疊值。`EXCLUDE USING gist (room_id WITH =, booking_period WITH &&)` 防止房間重複預訂。需要適當的索引型別(通常是 GiST)。

## 索引

- **B-tree**: 等值/範圍查詢的預設值(`=`、`<`、`>`、`BETWEEN`、`ORDER BY`)
- **複合索引**: 順序很重要—如果最左前綴相等則使用索引(`WHERE a = ? AND b > ?` 使用 `(a,b)` 索引,但 `WHERE b = ?` 不使用)。將最具選擇性/頻繁篩選的欄位放在前面。
- **覆蓋索引**: `CREATE INDEX ON tbl (id) INCLUDE (name, email)` - 包含非鍵欄位,用於僅索引掃描而不訪問資料表。
- **部分索引**: 用於熱子集(`WHERE status = 'active'` → `CREATE INDEX ON tbl (user_id) WHERE status = 'active'`)。任何帶有 `status = 'active'` 的查詢都可以使用此索引。
- **表示式索引**: 用於計算搜尋鍵(`CREATE INDEX ON tbl (LOWER(email))`)。表示式必須與 WHERE 子句完全相符:`WHERE LOWER(email) = 'user@example.com'`。
- **GIN**: JSONB 包含/存在、陣列(`@>`、`?`)、全文搜尋(`@@`)
- **GiST**: 範圍、幾何、排除條件約束
- **BRIN**: 非常大、自然排序的資料(時間序列)—最小儲存開銷。當磁碟上的列順序與索引欄位相關時(插入順序或 `CLUSTER` 後)有效。

## 分割

- 用於非常大的資料表(>100M 列),其中查詢持續在分割鍵上篩選(通常是時間/日期)。
- 替代用途:用於資料維護任務決定的資料表,例如定期修剪或批量替換資料
- **RANGE**: 時間序列常用(`PARTITION BY RANGE (created_at)`)。建立分割:`CREATE TABLE logs_2024_01 PARTITION OF logs FOR VALUES FROM ('2024-01-01') TO ('2024-02-01')`。**TimescaleDB** 自動化基於時間或 ID 的分割,配合保留原則和壓縮。
- **LIST**: 用於離散值(`PARTITION BY LIST (region)`)。例如:`FOR VALUES IN ('us-east', 'us-west')`。
- **HASH**: 無自然鍵時平均分配(`PARTITION BY HASH (user_id)`)。建立 N 個模數分割。
- **條件約束排除**: 需要分割上的 `CHECK` 條件約束,供查詢規劃器修剪。宣告式分割(PG10+)自動建立。
- 優先使用宣告式分割或超表。不要使用資料表繼承。
- **限制**: 無全域 UNIQUE 條件約束—在 PK/UNIQUE 中包含分割鍵。不支援從分割資料表的 FK;使用觸發器。

## 特殊考量

### 頻繁更新的資料表

- **分離熱/冷欄位**—將頻繁更新的欄位放在單獨的資料表中以減少膨脹。
- **使用 `fillfactor=90`** 為避免索引維護的 HOT 更新留出空間。
- **避免更新索引欄位**—防止有益的 HOT 更新。
- **按更新模式分割**—將頻繁更新的列與穩定資料分離到不同的分割中。

### 頻繁插入的工作負載

- **最小化索引**—僅建立查詢所需的索引;每個索引都會減慢插入速度。
- **使用 `COPY` 或多列 `INSERT`** 而非單列插入。
- **UNLOGGED 資料表** 用於可重建的暫存資料—寫入速度快得多。
- **延遲索引建立** 用於批量載入—>刪除索引、載入資料、重建索引。
- **按時間/雜湊分割** 以分散負載。**TimescaleDB** 自動化頻繁插入資料的分割和壓縮。
- **使用自然鍵作為主鍵**,例如 (timestamp, device_id),如果強制執行全域唯一性很重要,許多頻繁插入的資料表根本不需要主鍵。
- 如果確實需要代理鍵,**優先使用 `BIGINT GENERATED ALWAYS AS IDENTITY` 而非 `UUID`**。

### Upsert 友善設計

- **需要衝突目標欄位的 UNIQUE 索引**—`ON CONFLICT (col1, col2)` 需要完全相符的唯一索引(部分索引無效)。
- **使用 `EXCLUDED.column`** 參照即將插入的值;僅更新實際變更的欄位以減少寫入開銷。
- **`DO NOTHING` 更快** 於不需要實際更新時的 `DO UPDATE`。

### 安全的架構演進

- **交易式 DDL**: 大多數 DDL 操作可在交易中執行並復原—`BEGIN; ALTER TABLE...; ROLLBACK;` 用於安全測試。
- **並行索引建立**: `CREATE INDEX CONCURRENTLY` 避免阻塞寫入,但無法在交易中執行。
- **易變預設值造成重寫**: 使用易變預設值(例如 `now()`、`gen_random_uuid()`)新增 `NOT NULL` 欄位會重寫整個資料表。非易變預設值很快。
- **先刪除條件約束再刪除欄位**: `ALTER TABLE DROP CONSTRAINT` 然後 `DROP COLUMN` 以避免相依性問題。
- **函式簽章變更**: 不同參數的 `CREATE OR REPLACE` 會建立多載,而非替換。如果不需要多載,則 DROP 舊版本。

## 產生欄位

- `... GENERATED ALWAYS AS (<expr>) STORED` 用於計算的可索引欄位。PG18+ 新增 `VIRTUAL` 欄位(讀取時計算,不儲存)。

## 擴充功能

- **`pgcrypto`**: 密碼雜湊的 `crypt()`。
- **`uuid-ossp`**: 替代 UUID 函式;新專案優先使用 `pgcrypto`。
- **`pg_trgm`**: 使用 `%` 運算子、`similarity()` 函式的模糊文字搜尋。使用 GIN 索引加速 `LIKE '%pattern%'`。
- **`citext`**: 不區分大小寫的文字型別。優先使用 `LOWER(col)` 的表示式索引,除非需要不區分大小寫的條件約束。
- **`btree_gin`/`btree_gist`**: 啟用混合型別索引(例如 JSONB 和文字欄位的 GIN 索引)。
- **`hstore`**: 鍵值對;大多被 JSONB 取代,但對簡單字串對應有用。
- **`timescaledb`**: 時間序列必備—自動化分割、保留、壓縮、連續聚合。
- **`postgis`**: 超越基本幾何型別的全面地理空間支援—基於位置的應用程式必備。
- **`pgvector`**: 嵌入的向量相似度搜尋。
- **`pgaudit`**: 所有資料庫活動的稽核記錄。

## JSONB 指引

- 優先使用 `JSONB` 配合 **GIN** 索引。
- 預設:`CREATE INDEX ON tbl USING GIN (jsonb_col);` → 加速:
  - **包含** `jsonb_col @> '{"k":"v"}'`
  - **鍵存在** `jsonb_col ? 'k'`,**任何/所有鍵** `?\|`,`?&`
  - 巢狀文件上的 **路徑包含**
  - **析取** `jsonb_col @> ANY(ARRAY['{"status":"active"}', '{"status":"pending"}'])`
- 大量 `@>` 工作負載:考慮 opclass `jsonb_path_ops` 用於更小/更快的僅包含索引:
  - `CREATE INDEX ON tbl USING GIN (jsonb_col jsonb_path_ops);`
  - **取捨**: 失去對鍵存在(`?`、`?|`、`?&`)查詢的支援—僅支援包含(`@>`)
- 特定純量欄位的等值/範圍:使用 B-tree 擷取和索引(產生欄位或表示式):
  - `ALTER TABLE tbl ADD COLUMN price INT GENERATED ALWAYS AS ((jsonb_col->>'price')::INT) STORED;`
  - `CREATE INDEX ON tbl (price);`
  - 優先使用 `WHERE price BETWEEN 100 AND 500`(使用 B-tree)這類查詢,而非沒有索引的 `WHERE (jsonb_col->>'price')::INT BETWEEN 100 AND 500`。
- JSONB 內的陣列:使用 GIN + `@>` 進行包含(例如標籤)。如果僅進行包含,考慮 `jsonb_path_ops`。
- 將核心關聯保留在資料表中;JSONB 用於選用/變數屬性。
- 使用條件約束限制欄位中允許的 JSONB 值,例如 `config JSONB NOT NULL CHECK(jsonb_typeof(config) = 'object')`


## 範例

### Users

```sql
CREATE TABLE users (
  user_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE UNIQUE INDEX ON users (LOWER(email));
CREATE INDEX ON users (created_at);
```

### Orders

```sql
CREATE TABLE orders (
  order_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(user_id),
  status TEXT NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING','PAID','CANCELED')),
  total NUMERIC(10,2) NOT NULL CHECK (total > 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON orders (user_id);
CREATE INDEX ON orders (created_at);
```

### JSONB

```sql
CREATE TABLE profiles (
  user_id BIGINT PRIMARY KEY REFERENCES users(user_id),
  attrs JSONB NOT NULL DEFAULT '{}',
  theme TEXT GENERATED ALWAYS AS (attrs->>'theme') STORED
);
CREATE INDEX profiles_attrs_gin ON profiles USING GIN (attrs);
```
